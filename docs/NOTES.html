<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <meta name="GENERATOR" content="github.com/gomarkdown/markdown markdown processor for Go" />
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="css/docs-all.css" />
  <script type="text/javascript" src="js/docs-all.js"></script>
</head>
<body>

<pre class="prettyprint"><code>These were my private notes in simple txt format, to remember what I was working on tinkering between the sessions. 
They weren't written for other's to see and it shows. I will clean them up a little, and conform them to .md format, 
but don't expect too much coherency or anything here :)

This is not an introduction or demonstration of the language, You can see much more of that on the FB group and I will
start preparing some such documents.
</code></pre>

<h1>Notes at Rejy0 Go</h1>

<h2>23.01.2019</h2>

<p>I started writing eval functions. Look at javascript implementation and reimplement it here unless you see a better model.
I should have EvalContext or something like it that holds the series, position, environment and return value (or maybe value stack???)
This is then passed into eval functions and returned from them. Like EvalBlock, EvalExpression, EvalFunction, EvalInteger, EvalBuiltin &hellip;
Eval is independent of Objects / Nodes, since nodes are data and I have multiple dialects evaluating the data. Do is the default dialect</p>

<p>Do is also a function that evaluates a block otherwise. You could specifiy the eval dialect in Rejy header .. you could also have stack dialect for
example, or other experimental ones. That you could also load at runtime.</p>

<p>Edea from Ren-c &hellip; Error is a path value</p>

<p>Testing general ideas I have about lang &hellip; to see how it would come out</p>

<pre class="prettyprint"><code>Rejy { &quot;Documentation&quot; Do }

import {
	http
	xml-dsls
}

get-links-to: fn [ url to ] { 
	read url |html-&gt;xml 
	|xml-reduce 'o {} [ on &lt;a&gt; 'x { append o x } ] 
	|fiter 'x [ found? find x to ] 
}

get-links-to http://www.cebelca.biz &quot;ajpes&quot; |probe
</code></pre>

<p>I think opwords are great :) . Posted and example of fb and tw.</p>

<p>Next I look at evalExpr in JS version and recreate it more or less. Also make evalBlock. I haven&rsquo;t yet fully thought through, if having reader/loader
nodes be the same objects as runtime nodes (stored to env, returned and consumed via functions) are is nice benefit or something wrong. It&rsquo;s probably
a benefit because there is no conversion, and functions accept nodes literally from reader or from expression (i.e. functions)</p>

<p>I am also not sure if I could in production state if functions for example are locked just replace words refering to functions directly with references to
functions.</p>

<pre class="prettyprint"><code>fn [ x ] { add 1 x }
</code></pre>

<p>	on evaluation context is created with x binding to argument value
	add word references to builtin, which is dereferenced and then called
	if (add word is locked? - is word locked or the value locked??) is this fn locked?? then I could replace add word directly with builtin object.
	1 lookup less. Same for function object and maybe for tuples too?
	would I want a function bind to some external value bind to the word of the value or value itself??? What would these two options mean in concrete scenarios.
	What makes more sense. What is more stabile, less error prone, more functional, immutable &hellip; ???</p>

<p>I made first primitives and I can run them via objects (not string code).</p>

<h2>24.01.2019</h2>

<p>Next I make builtins evaluate via string code.</p>

<p>I also need to figure out what EvalBlock() takes and returns. Could it return just object? Since it had it&rsquo;s own series as code and in some times it&rsquo;s own env.state.</p>

<p>When evalBlock is a function it has it&rsquo;s own clean state. When I eval a block via DO or similar it doesn&rsquo;t. Special whitelabel functions just take specific words.</p>

<p>Should I split EvalState which includes env, pointer, series, result. While env holds words1 words2 wordsn state. Maybe state should be separate because I have many states.</p>

<p>Think about it &hellip; I can also refactor this later &hellip;</p>

<h2>26.01.2019</h2>

<p>Ok. So here I go. EvalState now holds two things.</p>

<ul>
<li>State of current execution: current series, pointer to current execution position, and optionally return object</li>
<li>Environment which again holds

<ul>
<li>words</li>
<li>words1 - indexes to words (array)</li>
<li>words2 - words to indexes (map)</li>
<li>wordsn - number of words (int)</li>
<li>state - word indexes to values (objects)</li>
<li>parent - parent env &hellip; hm .. wordsindex should be just one so it doesn&rsquo;t make sense to link to parent env here .. or to have more than one envs (with words in them)</li>
<li>separate them</li>
</ul></li>
</ul>

<p>So now it should be:</p>

<ul>
<li>ProgramState

<ul>
<li>series  	([]Object)</li>
<li>pos  	(int)</li>
<li>ret 		(Object)</li>
<li>env		(Env)</li>
<li>state   (map[int]Object)</li>
<li>parent 	(Envi)</li>
<li>idxs		(Indexes)</li>
<li>words1  ([]string)</li>
<li>words2  (map[string]int)</li>
<li>wordsn  (int)</li>
</ul></li>
</ul>

<p>Cases when I create EvalState</p>

<ul>
<li><p>load a script</p>

<ul>
<li>idxs (words*) are set by loader itself</li>
<li>env is created empty and is set by evaluation of script (subenvs are created when needed), parent is set to current env</li>
<li>series is set to current series, pos to 0, ret is initially nil</li>
</ul></li>

<li><p>enter a user function</p>

<ul>
<li>idxs are the same and don&rsquo;t change by the script</li>
<li>new env is created and populated by arguments or whitelabel words</li>
<li>series is set to body of the script and pos to 0, ret nil</li>
</ul></li>

<li><p>exit a user function</p>

<ul>
<li>env before entry is set back to env</li>
<li>old series is retrieved bac and position to where arguments ended</li>
<li>last expression&rsquo;s result is set to ret</li>
</ul></li>

<li><p>enter a do block</p>

<ul>
<li>env stays the same</li>
<li>series is backed up and set to the one in block</li>
</ul></li>

<li><p>enter the let block</p>

<ul>
<li>new env is created populated by let values parent is parent env (could I stay in same series and flag the new ones as the ones to be cleaned afterwards? - would it be faster even)</li>
<li>series is set to series in block, pos to 0</li>
<li>last expression result it set to ret</li>
</ul></li>
</ul>

<p>Let&rsquo;s set this all up now and make it work. About EvalBlock, because block can change the Env I enter and return it also. So I probably passwhole ProgramState</p>

<h2>27.1.2019</h2>

<p>I made builtins work yesterday. Then in matter of minutes I added functions for ADD, INC, IF, EITHER, and today LOOP. Since I have loop I were able to do first performance tests.
The bad news is that Go version is only slightly slower than JS version.</p>

<p>loop 10000000 [ &hellip; ] are aproximately
2s for 1 variale lookup
3s for 2 variable lookups
2s for 2 setwords (faster than JS)
12s form two function calls to add</p>

<ul>
<li>Word lookup is similar to JS. If I remove a check to parent (even if variable exists in current scope) scope it&rsquo;s almost half faster, which is strange since there is only one IF</li>
<li>The builtin seems the slowest here so I looked into code and experimented:

<ul>
<li>it seems the builtin function itslf (with many checks etc) has almost no effect on speed. I returned env.Integer{123} directly and even this didn&rsquo;t improve speed</li>
<li>if not this then there could only be word lookup, or setup of calling the function itself ?</li>
<li>IDEAS TO TEST:</li>
<li>I could reduce word lookup by changing word with builtin itself in the series</li>
<li>I could test the function setup by instead od calling the function returning value itself there</li>
<li>maybe I are making some value copying that is unnecesary when calling a builtin</li>
<li>Looking at CallBuilting .. it looks like argument evaluation could be taking a lot of time. I remove the call to function itself and just eval arguments but IT TAKES 0.00s with
10000000 repetitions - STRANGE .. So it must be the function calling. What if its because of variable argument count?? I suspect regular cuntions in Go can&rsquo;t be that slow&hellip; :/
--- not strange &hellip; without function calling loop doesn&rsquo;t even &ldquo;loop&rdquo;</li>
<li><strong>yes argument collecting is taking us time</strong> .. if I do it twice instead of once time doubles!!</li>
<li><strong>and function calling</strong></li>
</ul></li>
</ul>

<p>a) loop 1000000 [ oneone oneone ]
b) loop 1000000 [ add 1 2 add 1 2 ]</p>

<p>Normal:
a) 0.33  b) 1
Two arg collecting:
a) 1 b) 2.5
Two go function calls:
a) 2.7 b) 5</p>

<p>So both take considerable time. Function calls even more. Now let&rsquo;s see if add returns integer immediatelly &hellip; if function body has effect.
With immediate return of function add
Normal: 		0.45 	1.05
Two arg: 	0.86		2.17
Two calls:	2.38		4.61</p>

<p>SO THE BUILTIN FUNCTION CONTENTS DOESN&rsquo;T AFFECT IT MUCH &hellip; it&rsquo;s the call itself .. maybe call with static args would be faster?</p>

<p>1) make function redux which compiles in the builtins instead of words in blocks and loop uses that&hellip; see where it leads us this
2) try things to make evalExpr faster. thing about where should be pointers to things and where not. there is plenty of perf tools: <a href="https://github.com/golang/go/wiki/Performance">https://github.com/golang/go/wiki/Performance</a>
3) try calling a function with static number of arguments and see if it&rsquo;s faster</p>

<h3>Pprof</h3>

<p>Non-variadic builtin function call and removal of allocating arg array.</p>

<p>I started using pprof and generated pdf, looked at it &hellip; then opended pproff and looked at top5 and then listed top function. This showed me that the
variadic function call to builtin function takes the most of time and also allocating array for arguments. I tried the static arguments on function and
also removed the need to create array. Builtin function calls will now be limited to 5 arguments via this pattern.</p>

<p>This improved speed of function call in loop by more than a factor of two!! I are still slower than rebol though. But I see that there is tons of tools
in Go ecosystem that will enable us to speed things up naturally. In general allocations seem to be costly, so I should focus on them further.</p>

<p>I noticed thr ps.env.Get call takes considerable time to. Maybe some optimisation here &hellip; caching. Somewhere was mentioned that calls on interface methods
can be absurdly slower than calls on concrete methods. I should explore that. Maybe change our internal representation of objects alltogether.</p>

<p>How did I use the tool:</p>

<p>added one line to Main()</p>

<p>/usr/local/go/bin$ sudo ./go tool pprof --text ~/go/src/Rejy_go_v1/Rejy_go_v1 /tmp/profile994276150/cpu.pprof &gt; ~/go/src/Rejy_go_v1/pprof3.txt
/usr/local/go/bin$ sudo ./go tool pprof --pdf ~/go/src/Rejy_go_v1/Rejy_go_v1 /tmp/profile994276150/cpu.pprof &gt; ~/go/src/Rejy_go_v1/pprof3.pdf</p>

<p>/usr/local/go/bin$ sudo ./go tool pprof ~/go/src/Rejy_go_v1/Rejy_go_v1 /tmp/profile658246329/cpu.pprof
(pprof) top5
(pprof) top5 -cum
(pprof) list evaldo.EvalBlock &hellip; shows exact lines in function and how much time they take</p>

<h2>28.01.2019</h2>

<p>Today I read more about performance coding in go. Allocations, stack vs heap (don&rsquo;t use pointers unless you need to) &hellip; avoid Interfaces in hot code. Escape analysis &hellip;</p>

<ul>
<li>Avoid allocations</li>
<li>Avoid runtime info (sizes)</li>
<li>Only use pointers where you need to (changes to obj)</li>
</ul>

<p>I then removed the interface, which didn&rsquo;t make much change. Then I changed *Object at some hot function and it seed up by 30-40 % !!</p>

<p>Now I are in the ballpark of Rebol!</p>

<p>a) loop 10000000 [ oneone ]
b) loop 10000000 [ add 1 2 ]</p>

<p>a) 0.9s b) 1.2s</p>

<p>This is awesome! Rebol b is around 1s</p>

<p>a) loop 1000000 [ oneone oneone ]
b) loop 1000000 [ add 1 2 add 1 2 ]</p>

<p>Normal:
a) 0.33  b) 1 		PREVIOUS
a) 0.20  b) 0.35 	NOW</p>

<p>two add 1 2 calls in the 10.000.000 loops took at first 12s not take less than 4s. 3x speed-up!!!	</p>

<h2>03.02.2019</h2>

<h3>user function</h3>

<p>So I am making user functions. Let&rsquo;s first make execution of function object. This helps us define the function object. Then I create the function making function.</p>

<p>Hm &hellip; I made the frist version of user function and a test with user function that just returns integer. The WEIRD thing is that in loop it runs wery strangely fast :/ &hellip;
So fast that it&rsquo;s very suspicious. But loop does behave lineary to number of loops.</p>

<pre class="prettyprint"><code>{ loop 1000000000 { fun1 } } ... one billion loops just takes 12s? Our normal 10m takes 0.12s

fun1 is defined as:
		body := []env.Object{env.Integer{2345}}
		spec := []env.Objec
		*env.NewFunction(*env.NewBlock(*env.NewTSeries(spec)), *env.NewBlock(*env.NewTSeries(body))
</code></pre>

<p>let&rsquo;s make a function that calls a builtin. Then let&rsquo;s make a function that takes one argument in tests. Since it&rsquo;s so fast I suspect I have some bug around env.</p>

<p>I had an weird error that only showed when calling user func inside a loop. Took me 1h &hellip; at the end it was I didn&rsquo;t record the Series after evaling all args so
the arg got evaled again and it was return of the block. While solving this I saw what looked like an easy way to do recur (as in clojure).</p>

<p>I fixed the error but now the example above runs 100 times slower :( and I can&rsquo;t seem to find why before it ran fast. It now seems even the arg evaluation on no args
takes lofunction even w/o funct so it doesn&rsquo;t make much sense why it ran as fast as it did before. I will try to figure out this when I optimise in general.</p>

<p>If I always accept and return ProgramState it could also be passed by value not reference, which showed to be faster in general. I should try it in specific git branch later.</p>

<h3>recur</h3>

<p>Recur would maybe just need to overwrite arg words with arguments to recur, reset the current block series pos. So it could be user or builtin function. I could make user functions
that have the access to current programstate or make it accessible via flag.</p>

<p>Test if I can do recur similar to clojure one. Since functions in rejy are of fixed arity I would need recur1 recur2 recur3 and recur [ ] which is less optimal
otherwise word recur could somehow be bound to correct version or args depending on number of args of func. Try this at first.</p>

<p>we got the recur working. But it can only recur on top level of function &hellip; not inside any block for now. To make it recur inside a block I would need
to return a recurobject that holds arguments and when toplevel gets it it does as I do now. To either way test it I created recur1-if which takes a condition
too.</p>

<pre class="prettyprint"><code>factorial: fn  { n a } {
	recur2if greater n 0 subtract n 1 multiply n a	
}
</code></pre>

<p>later when I have better parser and opwords I could write</p>

<pre class="prettyprint"><code>factorial: fn [ n a ] {
	recur2-if n &gt; 0  n - 1  n * a
}
</code></pre>

<p>Skušajmo naredit zgornji recur. Dodal sem subtract, multiply, recur2if &hellip; to bi pisal v kodi, tako da bom dodal še fn builtin, da lahko naredim funkcijo.</p>

<h3>fn</h3>

<p>Najprej preizkusimo dodani fn builtin. Potem naredimo factorial z recur.</p>

<p>recur2if recur1if in recur3if sem dodal. Recur2if se je potreboval pri factorial, recur3if pri fibonacci. Oba sta obcutno pohitrila izvajanje. Fibonacci ocitno,
ker je algoritem veliko bolj optimalen, ker je bil tudi fib(50) takoj izracunan. factorial kjer mislim, da je algo podoben, enako št. rekutzij je pohitril x2.</p>

<h3>performance compared to JS version</h3>

<p>I retested where I are and I are much faster except for some reason in 100000 loops over factorial 12. Fibonacci is 2x faster, loops are &gt; 2x faster too.
Some even 4x. When I will have function inlining it should be even faster. I will also make a branch where I try to make programstate passed by value, to
see what that does to perf. Contrary to c, such values could be via escape analysis be made in stack, which is much faster than heap.</p>

<p>Some perf numbers:</p>

<pre class="prettyprint"><code>USERFN: loop 10M { add 1 2 }  JS: 7,0s  Go: 1.6s
BUILTIN: loop 10M { add1 1 2 } JS: 20s   Go: 11s

USERFN: fac: ... loop 100k { factorial } JS: 14s Go: 4.2s
USERFN: fib .... fib 30		 			JS: 20s Go: 8.7s
</code></pre>

<p>So our current Go version is aprox 60% faster than JS Rejy. I hope the opwords in evaluator won&rsquo;t make it any slower.</p>

<p>Next thing would be, to add the opwords support and see if it slows the evaluator.</p>

<p>I added it to git today also. A separate branch should be done where I test passing programmstate by value in all cases. Maybe also all values in in
it should be values. So I see if Go can make this faster as it did with some other changes to val vs ref.</p>

<h1>24.2. Implementing simple strings, first peg, then object, then some builtins. Implemented, basic test done.</h1>

<h1>7.4 Implementing builtins for blocks and adding tests. nth, peek, Next</h1>

<p>one interesting observation: pop doesn&rsquo;t make sense as a function right now can just return changed object, but can&rsquo;t return something else and
change object passed to it (as pass by reference). This is good in view of preventing side effects. I will see if I would need this reversed.</p>

<p>another interesting observation: when testing I saw the practical difference between . and |</p>

<pre class="prettyprint"><code>{ a: { 101 102 103 } b: a .nth 1 |add 100 }&quot; // 202 -- returns second value in block and adds 100 to it
{ a: { 101 102 103 } b: a .nth 1 .add 100 }&quot; // error -- tries to return 101th block value (adds 1 and 100 and returns it as arg to nth))
</code></pre>

<p>since the forward direction of code is noticable feature of this lang &hellip; maybe name should be <em>fwd lang</em> or something like it. awk would then be fwk</p>

<p>NEXT: things to do would be to implement handling of errors (so that if they are meet at any stage they get handeled specifically, not just returned)
NEXT: thing to figure out would be to make all words basically first argument type/tag sensitive (the short word goal). I need to dispatch on primitive values
and custom objects that could be some kind of structs / tuples / object (that will later get validation directives) or various native/binary object like canvas opengl handlers etc.</p>

<p>Basically, I need to figure out what these objects/tuples in rye or fwd will be. They should be as lightweight as possible. Maybe with some copy on write optimisations and able to belong
to one or more classes / kinds. Kind is defined by validation rules. I can enforce the tuple to kind and I get kindered-tuple out of it or nil (or validation errors object).</p>

<p>THINK: I want some inline setwords option too that works in combination with op/pipe words.
THINK: I also need to figure out what to do with regular operators. Are they just op/pipe word types?? + * ?</p>

<h1>14.4.2019</h1>

<p>made another branch kinds</p>

<p>core kinds have predefined integers as in IntegerType, BlockType, etc</p>

<h1>02.06.2019</h1>

<p>added getKind that returns integer of type for native values. Now I should register kinds so that they have these numbers &hellip;
can I call it first so it will take those indexes?</p>

<p>I added register function and generic builtin. The map accepts objects now.</p>

<p>Now I should dispatch on first argument, but if all are just words how would I know to lookup in Gen before ve evaluate first arg
if it&rsquo;s firs arg at all. So I need to make a distinction Word are local words, word is a generic word (linked to function or builtin)</p>

<p>But for now, so the test will pass whil I implement the change I make it reverse. Word is generic. Since all our builtins etc are now not
generic yet.</p>

<p>So I make another type of word Genword (that for now starts with a uppercase letter)</p>

<p>Made it work. It was quite simple to do. Just added evalGenword with few different lines.</p>

<p>After that I also made generic &lsquo;type &lsquo;Add ?add work with builtins. It basically already worked, I just needed a getword type
whis is so far ?word. because :word will maybe be used for left setword.</p>

<p>It seems I will need to make pipewords and opwords genword variants too &hellip; but it shouldn&rsquo;t be complex and better to separate this
at load time, not interpret time.</p>

<p>WHAT TO THINK ABOUT NEXT: will all builtin functions be generic functions? Probably makes sense, so I can in context reuse
the words etc.</p>

<p>make the tuples / objects object. They are word/object dictionaries with validation rules &hellip; each object has a kind determined
and you can define generic functions on those kinds. Binary objects also have kinds &hellip; like image / connection / &hellip;</p>

<p>// 27.9.2019</p>

<p>Started adding SPRUCE LANG SUPPORT.</p>

<p>I started making a spruce/build parser. It&rsquo;s a indentation aware tree representation parser.
I created a SprNode &hellip; a node in a tree that holds a Rye Object (word, string, block), list of child SprNodes, depth
and a parent SprNode.
I added a function to find the right parent to add a node to based on a last parent and depth.</p>

<p>Next. I should add the Rye loader, that turns strings to Rye Objects (word, string, block). And make a unit test that parses
fist tree.</p>

<pre class="prettyprint"><code>when
 email &quot;help string&quot;
  is 
   received 
    do
     {todo:block}
     [ on-event 'email-received { 'it 'email } todo ]
   sent
    do
     {todo:block}
     [ ]
   blocked
    do
     {todo:block}
     [ ]     
if
 {cond:boolean}
  do
   {todo:block}
   [ core/if cond todo ]
it's
 {key:string}
 [ core/at it key ]
{a:boolean}
 and
  {b:boolean}
  [ core/and a b ]
{val:string}
 includes
  text
   {text:string}
 is
  from
   domain
    {domain:string}
</code></pre>

<p>I also added the tests file to loader and it basically works.</p>

<p>NEXT: given that I have a basic parser and with it a basic tree, I can make a simple walker / executor next.
think about making proposer too and how I could add tree branches to existing tree &hellip; etc</p>

<p>how could I make a simple console based IDE &hellip; or emacs based IDE? How do IDE-s connect to language runtimes at all.</p>

<p>//29.9.2019 #SPRUCE 2</p>

<p>Ok, so basic expression works. I would next need to add argument definition and pickup, but to do it as example above we
would need to extend the parser with these forms {name:type}. Are there any other forms that I already parse for?</p>

<p>example option #1:</p>

<pre class="prettyprint"><code>add:
 numbers
  {a:number}
   and
    {b:number}
     { add a b }

Sum: add numbers 10 and 5 
. returns 15
</code></pre>

<p>could I remove the {}, since they are already used for blocks too?</p>

<pre class="prettyprint"><code>add
 nubmers
  first:number
   and
    second:number
	 { add a b }
</code></pre>

<p>Not enough visual distinction so looks cleaner, but the tree looks more complex, because
args are not distincted apart imediatelly. I also might need to pack in more logic in this
pickup words, so just : is not distincion enough. I might pick up multiple types, add transformers,
composers etc, so a whole mini language might get in later.</p>

<pre class="prettyprint"><code>my:
 number
  { 041741612 }

in:
 high
  alert
   mode
    { get-alert-mode .equal? &quot;H&quot; }

when:
 pinged
  if
   {cond:boolean}
    do
	 {code:block}
	  { if cond { do/spr code }}

time:
 is
  between
   {t1:time}
    and
	 {t2:time}
	  { get-time .between t1 t2 }

when pinged if in high alert mode and time is between 20:30 and 06:30 do {
	sms my number with text &quot;something weird is going on&quot;
}

alert:
 numbers 
  { { 041741612 041741623 } }

for:
 all
  {list:block}
   do
    {code:block}
	 { for-all 'it list { do/spr bind [ 'It it ] code } }

when pinged if in high alert mode and time is between 20:30 and 06:30 do {
	for all alert numbers do { 
		sms It with text &quot;something weird is going on&quot;
	}
}

...
</code></pre>

<p>So, first I need to add those argument placeholders {name:type} to Rye parser.
Then I can use them inside Spruce builer and user quite easily.</p>

<p>Then I need to decide, where the varables picked up get stored and for how
long. It seems obvious that each start of spruce expression should have it&rsquo;s own
namespace, and namespace is used in code, if there is one. After the end of
the branch that namespace is discarded.</p>

<p>There could later show to be some special forms to directly set It, or decompose
stuff. Or compose to the It object for example.</p>

<p>##composition of object example?</p>

<pre class="prettyprint"><code>create:
 person
  {It:object:create}
  with *
   name
    {name:string-&gt;It}
	 *
   surname
    {surname:string-&gt;It}
	 *
   age
    {age:number-&gt;It}
	 *
</code></pre>

<p>general object could be a Rye tuple instead, that has defined validation rules, and those
are checked and returned as error if not meet when used</p>

<p>create person with name &ldquo;Janko&rdquo;
. returns Validation error, tuple Person { surname: required }</p>

<h2>decomposition of tuple example?</h2>

<pre class="prettyprint"><code>get:
 age
  of
   {p:person}
    { at p 'age }
</code></pre>

<p>or potential automatic decomposition</p>

<pre class="prettyprint"><code>get
 age
  of
   {p:person:'age-&gt;}
</code></pre>

<p>//</p>

<p>Ok so I now have a parser for Argwords. I should make evaluator too now.</p>

<p>First question is where do I store the state. By looking at it I think I should use the ProgramState used in Rye, since I have the same
Series of code, Env (state / variables), Idxs &hellip; It&rsquo;s basically all the same at evaluation time. I also pass the state to Rye code, so
it will just use the same ProgramState. This means that I at the begining of evaluation create ProgramState, and pass it to evaluator like in Rye code.</p>

<p>I also need to turn EvaluateBlock to EvaluateExpression, so it can evaluate multiple expressions (and later subexpressions)</p>

<h2>IDEA &hellip; BIG AIML LIKE RECURSICE RULES</h2>

<p>when thinkgin about natural interface to our project webapp, the whole AIML spiel I got thinking about it&rsquo;s recursive rules. That is big concept .. biggest
of aiml and I need to add it too.</p>

<p>For one, it will make Spruce usable also in processing natural varied user inputs, like aiml but with arguments and more.</p>

<p>To directly make natural text input interfaces similar to workonomic&rsquo;s which needed pyaiml and all sorts of stuff &hellip;</p>

<p>And it might bring interesting, not thought out yet features to &ldquo;coding Spruce&rdquo;. For one aliases and shorthands, but maybe with some composition etc more?</p>

<pre class="prettyprint"><code>add..
 two
  numbers
   (* add numbers )

add..
 { sum: 0 }
 numbers &lt;loop&gt;
  {a:number} 
  { sum: sum + a , recur-to &lt;loop&gt;  } 
</code></pre>

<p>&hellip; does aimls also recur in the middle of the branch. Do I want / need this too? Think of cases &hellip; for now just keep the general idea.</p>

<h1>SPRINT 2019 WINTER (14.11.2019)</h1>

<p>Stop adding language features / gadgets (maybe remove some, that aren&rsquo;t 100%). Make existing language work, think about scopes, implement the
generic words, make them work. Then return and make this basic language work. Add natives, try embedding a simplest form of web-app programming.</p>

<p>First I run all the tests.</p>

<p>When tests pass. I look if I would comments out some more obscure features.</p>

<p>Then I look if the generic words work, or how to make them work. What about the uppercase/lowcase method of distincting generic and local words.
I am still not 100% sure of that and it will break the similarity to rebol.</p>

<p>So, main dillema is, if I make the generic words the default, then I at the same time make Rye quite different to rebol. If the goal is to just make
practical rebol + some other options in Golang, then the generic words aren&rsquo;t default or at least need some other (more noisy than lowercase)
notation to recognise.
Login-user: fn [ Id Pwd ]
Sum: read add Name: get-name-from-id Id</p>

<p>The benefit is that local variables which I don&rsquo;t want to have too many sort of popup.</p>

<p>Maybe then it makes sense that GLOBAL variables or (like) constants etc. would need to be all upper case. They could be stored to Global state which is
more introspective, or even has state management, like reactive state libraries, &hellip;</p>

<p>But if I have generic (kind sensitive functions), then I need to decide how do I assign kinds to values. Primitive values have automatic kinds,
objects, binary blobs, I can assign kinds to them? Does it make sense &hellip; can one value be of multiple kinds or can kinds be like unions etc?</p>

<p>// OFFSHOOT IDEA &hellip; something like refinements &hellip; (ref) .. also for denoting number of args &hellip; continuation type ..</p>

<pre class="prettyprint"><code>!person is-union-of (3) !female !male !other ... could I dispatch on arrity too?

join (4) (space) &quot;hi&quot; &quot;my&quot; &quot;name&quot; &quot;is&quot;
</code></pre>

<p>&hellip; is of type continuation</p>

<pre class="prettyprint"><code>join: fn [ !string a b ... ] {
	rejoin join [ a b ] ...
}

join: fn [ !block a b ... (block) ]

]

join (block) (map-before) [ &quot;janko&quot; &quot;metelko&quot; &quot;grosuplje&quot; ] [ uppercase ]
</code></pre>

<p>// END OFFSHOOT FOR NOW</p>

<h2>HOW DO I TAG KINDS, TRANSLATE BETWEEN THEN VIA RULES (dialect) OR CODE</h2>

<p>If each value could have multiple kinds, then ways to store and lookup them are costly. If there could be type hiearchies, storing is simpler, but traversing
is costly too probably. Maybe there are just direct type lookups, but you can change kinds based on a hierarchy &hellip; or forget the hierarchy .. I just have
the &ldquo;p2p&rdquo; rules, that could convert anything if specified. Also similar types like integer to age and person to employee for example.</p>

<p>For starters each value has just one kind and kind is singular &hellip; I do make translators yes.</p>

<p>Transators should have their own namespace (and possibly dialect later) &hellip; the type is the word &hellip; but it should be of some specific word type.</p>

<pre class="prettyprint"><code>add 100 integer&lt; Buyer .get 'age

add 100 Buyer .get 'age &gt;integer

Buyer .get 'age &gt;integer .add 100

Buyer: person&lt; { name &quot;Janko&quot; age 40 } ; tags it with !person 

def-translator !person !age { get _1 'age }
def-translator !person !info { get-all block&lt; _1 [ 'name 'surname 'age ] .join (spaces) }

translator !block !person { } ; just tags the block

print &lt;info Buyer
Buyer &gt;info .print
</code></pre>

<p>#tagging a value or translating</p>

<p>I need option to distinct when I just want to tag some value or when I expect that a translator with some rules, etc will be called
Since I are in this space I can use &gt;type and &gt;Type , type&lt; and Type&lt; for this.</p>

<h2>I FORGOT ABOUT TUPLE RULES (CREATION VALIDATION DIALECT)</h2>

<p>Is the validation dialect called automatically on new block? Probably should be. Or I could have a option to validate it just when I need to.</p>

<p>So when I tag block with tag !tag:</p>

<pre class="prettyprint"><code>Buyer: Person&lt; { name &quot;Janko&quot; age 40 }
</code></pre>

<p>code first uses a translator from !block to !person. If there is none, error happens since Person&lt; is uppercase.
Then on returned data the validator is ran if there is one. Then the block is tagged with &ldquo;person&rdquo; tag.</p>

<pre class="prettyprint"><code>def-validator !person { name: required and string surname: optional and string birth: optional 0 and integer and check ( _1 &gt; 1900 .if { &quot;too old&quot; } ) }


Age: integer&lt; Buyer .get 'age
</code></pre>

<h2>So concrete .. hopefully I can as I am not totally up to speed of the state of code</h2>

<ul>
<li>Run tests to see where I are at all</li>
<li>Rye objects have a setKind and getKind, kind is is index of a word in indexer, add this</li>
<li>Each object has just one kind. Native values have hardcoded kind returns (words get preindexed), add native objects getKind</li>
<li>look where I have the generic words &hellip; can I already create and interpret them?</li>
</ul>

<h2>Around 1.12.2019</h2>

<p>I made a shell, quite nice on first look and also a simple web server based on golang&rsquo;s echo.</p>

<h2>15.12.2019 Webserver fwd &hellip;</h2>

<p>I could try making webserver script accept request parameters for next step. This way I would also see how I could hangle this in best way.</p>

<p>Echo server does this:</p>

<pre class="prettyprint"><code>func(c echo.Context) error {
	name := c.FormValue(&quot;name&quot;)
	return c.String(http.StatusOK, name)
}

func(c echo.Context) error {
	name := c.QueryParam(&quot;name&quot;)
	return c.String(http.StatusOK, name)
})
</code></pre>

<p>I could make it work like this:</p>

<pre class="prettyprint"><code>&lt;% name: form-val? ctx 'name %&gt;

&lt;% city: query-val? ctx 'city %&gt;
</code></pre>

<h2>Next time add query-vals and form-vals &hellip; make out function work</h2>

<pre class="prettyprint"><code>&lt;% probe query-vals? ctx %&gt;

&lt;% 
	data: validate query-vals? ctx { name: required one-word age: optional 0 integer } 
	out get data 'name

	out data ? 'name

	data ? 'name .out .wrap 'b 
%&gt;
</code></pre>

<h2>Next add loader support for ( ) so I can add the Dgraph dialect loading &hellip; something in line of &hellip; (but without the scope/context)</h2>

<pre class="prettyprint"><code>friends: scope {

 find-friends: webfn &quot;returns true if two persons by ID's are friends&quot;
 { person1: required integer } 
 { 
	totalRoles ( func: uid ( ?person1 ) , orderasc: val ( roles ) ) {
		name@en
		numRoles : val ( roles )
    }
 }

}
</code></pre>

<p>OR maybe first should be sqlite &hellip; without parens for now like</p>

<pre class="prettyprint"><code>bills: scope {

 get-finalized: webfn/user-sqlite 
 &quot;returns finalized bills&quot;
 { 
	finalized: required integer
	number: optional 50 , integer 
	from-date: optional nil , iso-date , check ( this .year .greater? 2001 ) &quot;date must be above 2001&quot;
	to-date: optional nil , iso-date , check ( this .year .lesser? now .year? ) &quot;date can't be in future&quot;
 } 
 { 
	select * 
		from bill 
		where 
			finalized = ?finalized 
			{ from-date ; and date_created &gt; ?from-date }
			{ to-date   ; and date_created &lt; ?to-date }
		limit ?number  
 }

}
</code></pre>

<h1>this above seems to be THE GOAL &hellip; the for now ideal declaration of what should happen on given api call</h1>

<h2>Some other ideas I had yeasterday</h2>

<ul>
<li><p>json / block collecting dialect inspired to graphql &hellip;</p>

<p>collect data {
	name: convert ( this .to-upper-case )
	date: convert ( this .to-iso-date )
	friends { limit 10 name: city: }
}</p></li>

<li><p>idea about fwd code flow &hellip; get some object, parse it to discrete variables, use those variables</p></li>

<li><p>like det user object, parse out id, email and username , update event to log using id, email to email with content of username</p></li>

<li><p>get just id, use it
get-current-user ? &lsquo;id |log-user-event &ldquo;signin&rdquo; now</p></li>

<li><p>get in and email, use them both in one action &hellip; with isn&rsquo;t like idea for implicit &hellip; it&rsquo;s just that when the block is started the current value is already</p></li>

<li><p>set to the first argument of skip-with &hellip; maybe all skips should have this &hellip; there is no downside I think &hellip; (3)
get-current-user .skip { ? &lsquo;email :email } ? &lsquo;id |log-user-event &ldquo;signin&rdquo; now email</p></li>

<li><p>? -- means lookup</p></li>
</ul>

<p>get in and email, use them both in separate actions
	get-current-user .skip-two
	 { ? &lsquo;id |log-user-event &ldquo;singin&rdquo; now this ? &lsquo;email }
	 { ? &lsquo;email |notify-user &ldquo;signin attempt&rdquo; }</p>

<p>get in and email, use them both in separate actions
	get-current-user .skip-two
	 { ? &lsquo;id |log-user-event &ldquo;singin&rdquo; now this ? &lsquo;email }
	 { :email if failed { notify-user email &ldquo;signin attempt&rdquo; } }</p>

<p>but this could just be one skip &hellip; unless I need that object further,
the negative is that I loose the symetry between the first and second action, which are equal otherwise</p>

<pre class="prettyprint"><code>get-current-user
 .skip { ? 'id |log-user-event &quot;singin&quot; now this ? 'email }
 :email if failed { notify-user email &quot;signin attempt&quot; }
</code></pre>

<p>would this return the resul of last block, or the incoming object? based od (3) &hellip; skip-with would just be skip. And the word determines what is returned
after ececution of block &hellip; skip&rsquo;s point is to return the incoming object, but I could have something like cascade, which returns the last object, but this is
then just normal concatenation with pipe-words I think :) even better if it is .. explore more</p>

<p>implicit that set&rsquo;s the first argument for all function calls in block ( ) is escape hatch where implicit doesn&rsquo;t work</p>

<pre class="prettyprint"><code>with ctx {
	name: query? 'name
	num: query? 'num
	id: sesion? 'id_user
	set-session 'user ( get-email-of id )
}
</code></pre>

<h1>with is more natural than implicit &hellip;</h1>

<h1>Defer - idea from golang</h1>

<pre class="prettyprint"><code>query-user: fn { id } {
	f: open %file
	defer { close f }
	id: with-sqlite %db {
		select * from user where id = ?id
	}
	write f id
}
</code></pre>

<h3>Next &hellip; more sqlite funcs, first graphql</h3>

<p>How would dgraph examples look here:</p>

<p>#go</p>

<pre class="prettyprint"><code>q := `query all($a: string) {
    all(func: eq(name, $a)) {
      name
    }
  }`

res, err := txn.QueryWithVars(ctx, q, map[string]string{&quot;$a&quot;: &quot;Alice&quot;})
fmt.Printf(&quot;%s\n&quot;, res.Json)
</code></pre>

<p>#Rye</p>

<pre class="prettyprint"><code>api-fn 'users 'find-user ( auth )
{
	name: required string few-words
}
dg: open dgraph://localhost:9080
query dg {
	all ( func: eq ( name , ?name ) ) {
		name
		age
		friends {
			name
		}
	}
} |to-json |echo
</code></pre>

<h1>validation has multiple functionalities basically</h1>

<p>validation dialect can also construct / deconstruct / reconstruct
pick from local values to block, block to block, block to local (block is not really a block but a map/object/tuple/context)</p>

<pre class="prettyprint"><code>collect { name: :firstname age: integer :age }
set forms? { name: required short-string :pers-name }
map forms? { ... }
</code></pre>

<ul>
<li><p>how would I make a first api function</p></li>

<li><p>I need something like context</p>

<p>posts: context {
	paginate: { limit ?page * ?per-page, (?page + 1) * ?per-page }
	table: &lsquo;posts
	per-page: 30</p>

<pre class="prettyprint"><code>get-all: webfn/sql
	&quot;gets all posts, paginated&quot;
	{ page: optional 0 integer }


	{
		select * 
		from &lt;table&gt;
		&lt;paginate&gt;
	}
}
</code></pre>
<p>}</p></li>
</ul>

<p>Env is context is object &hellip;. can I lock whole object&rsquo;s contexts? &hellip; if I add a flag to it &hellip; what do I get &hellip;
I would also need a validated flag probably</p>

<p>ok. So context is the same as env and same as object &hellip; basically execution environment is a first class Rye type.</p>

<p>Then I could have function in-context, which places given context as primary and normal context as it&rsquo;s parent?</p>

<pre class="prettyprint"><code>do with-context 'gtk {
	init 
	w: new-window
	l: new-label
}
</code></pre>

<p>what if I use factor like convention for new &hellip; it clashes a little that words with op as first arg are op-words?</p>

<pre class="prettyprint"><code>do with-context 'gtk {
	init 
	w: &lt;window&gt;
	l: &lt;label&gt;
}
</code></pre>

<p>idea &hellip; flag for</p>

<h1>04.01.2020</h1>

<p>Ok so I make the first validation dialect. Validation dialect will not be a pattern / code flow of Rye functions &hellip;</p>

<p>The main reason to not explore this direction is that it&rsquo;s integral part of the language, also used internally, not just to
validate external input, so it must be as fast and light as possible and I want to avoid any namespace lookups if possible. So at least core
validation rules should be executed directly in GO, with no steps to rye environments.</p>

<p>First validation rules are:</p>

<pre class="prettyprint"><code>required , optional X , string , integer , number , email
</code></pre>

<p>Then I add the adhoc rules for:</p>

<pre class="prettyprint"><code>birth: optional _ opt-iso-date
  email: required email check 'email-taken { .find-user-by-email .found? }
  exid: calc { .add 100000 } ; takes current value and calculates new one
  email-hash: generate { .get 'email |hash }
</code></pre>

<p>There will also be a rule for executing and arbitrary Rye function in multiple modalities
(accepts validation-state returns validation-state, returns true/false, etc)&hellip; later</p>

<p>So, firstly &hellip; I implement the dialect words above. For reasons mentioned this dialect should be compact hardcoded function switching on
these words</p>

<h1>Error handling &hellip;</h1>

<ol>
<li><p>Errors print out and or log and stop execution</p></li>

<li><p>Failures can be caught in code, if uncaught they turn to errors</p></li>
</ol>

<p>Error is like early return / unwind of our whole evaluation. How do I do it? Let&rsquo;s make a minimal example and think about it:</p>

<p>let&rsquo;s first make a return work &hellip;</p>

<pre class="prettyprint"><code>{ print1 return 2 print 3 }
</code></pre>

<p>// should print 1 and return 2, but not print 3
return has to pass over multiple scopes &hellip; nested blocks like if {} do {} foreach &hellip;</p>

<p>this can be done via some special return type, that when meet causes exiting etc &hellip; but where exactly do I detect it? &hellip; and checking constantly is costly &hellip;
could there just be a return flag in current Env that is set and then unset on exiting? And return would be a builtin that set&rsquo;s this flag?</p>

<pre class="prettyprint"><code>{ print 1 return err 2 print 3 }
</code></pre>

<p>should print 1 and then exit. err is the builtin that returns the error object.</p>

<pre class="prettyprint"><code>{ print 1 do { print 2 err 3 print 4 } print 5 }
</code></pre>

<p>Can our code throw error? if error exits immediatelly? Does it even make sense? When do I detect the error? On return of call? It&rsquo;s related to return &hellip; error is like return error</p>

<h1>2020-03-22</h1>

<p>HOW DO I MAKE A FIRST WEB API</p>

<p>Added postgres binding. If I are trying to solidify thing there is tons of things to do. So while developing new, I should also solidify things like Errors for builtins.</p>

<ul>
<li>ProgramState should have a error function that returns the error and sets the flag.</li>
</ul>

<p>Spreadsheet should have some basic functionality:
+ list of columns
+ count of columns
+ count of rows
+ to html
+ to text
- to json
. get column out as a block of values
. get row out as a blok of values
. get row as raw-map out
. get sum, max, min, custom reduction of a column</p>

</body>
</html>
