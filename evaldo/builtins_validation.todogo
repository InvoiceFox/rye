package evaldo

import "C"

import (
	"Ryelang/env"
	"database/sql"
	"fmt"
	"strconv"
	"strings"
)

// Integer represents an integer.
type ValidationError struct {
	message string
}

func Validation_EvalBlock(es *env.ProgramState) (*env.ProgramState, []interface{}) {
	values := make(map[string]interface{}, 0, 2)    // TODO ... what is this 2 here ... just for temp
	notes := make(map[string]ValidationError, 0, 2) // TODO ... what is this 2 here ... just for temp
	for es.Ser.Pos() < es.Ser.Len() {
		es, str, values = Validation_EvalExpression(es, values)
		bu.WriteString(str + " ")
		fmt.Println(bu.String())
	}
	es.Res = env.String{bu.String()}
	return es, values
}

func Validation_EvalExpression(es *env.ProgramState, vals []interface{}) (*env.ProgramState, string, []interface{}) {
	object := es.Ser.Pop()

	switch obj := object.(type) {
	case env.Integer:
		return es, strconv.FormatInt(obj.Value, 10), vals
	case env.String:
		return es, "\"" + obj.Value + "\"", vals
	case env.Word:
		return es, es.Idx.GetWord(obj.Index), vals
	case env.Getword:
		val, _ := es.Env.Get(obj.Index)
		vals = append(vals, val.(env.Integer).Value)
		return es, "?", vals
	case env.Comma:
		return es, ", ", vals
	default:
		return es, "Error 123112431", vals
	}
	return es, "ERROR", vals
}

var Builtins_validation = map[string]*env.Builtin{

	"validate": {
		Argsn: 2,
		Fn: func(env1 *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			arg0.Trace("OPEN :::::::::")
			switch str := arg0.(type) {
			case env.Uri:
				fmt.Println(str.Path)
				db, _ := sql.Open("sqlite3", "temp-database") // TODO -- we need to make path parser in URI then this will be path
				return *env.NewNative(env1.Idx, db, "Rye-sqlite")
			default:
				return env.NewError("arg 2 should be Uri")
			}
		},
	},
	"collect": {
		Argsn: 1,
		Fn: func(env1 *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			arg0.Trace("OPEN :::::::::")
			switch str := arg0.(type) {
			case env.Uri:
				fmt.Println(str.Path)
				db, _ := sql.Open("sqlite3", "temp-database") // TODO -- we need to make path parser in URI then this will be path
				return *env.NewNative(env1.Idx, db, "Rye-sqlite")
			default:
				return env.NewError("arg 2 should be Uri")
			}
		},
	},
	"pulldown": {
		Argsn: 2,
		Fn: func(env1 *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			arg0.Trace("OPEN :::::::::")
			switch str := arg0.(type) {
			case env.Uri:
				fmt.Println(str.Path)
				db, _ := sql.Open("sqlite3", "temp-database") // TODO -- we need to make path parser in URI then this will be path
				return *env.NewNative(env1.Idx, db, "Rye-sqlite")
			default:
				return env.NewError("arg 2 should be Uri")
			}
		},
	},
}
